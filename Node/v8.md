# V8垃圾回收
V8引擎是Google Chrome浏览器和Node.js使用的JavaScript引擎，它负责执行JavaScript代码并管理内存。V8引擎采用了多种策略来进行垃圾回收（Garbage Collection, GC），以确保内存的有效使用和避免内存泄漏。下面是V8引擎进行垃圾回收的详细过程和策略。

1. 分代垃圾回收（Generational Garbage Collection）
V8引擎基于分代垃圾回收的理念，将内存分为两个主要区域：新生代（Young Generation）和老生代（Old Generation）。

新生代（Young Generation）
Scavenge算法：新生代使用Scavenge算法进行垃圾回收。这个算法将新生代分为两个相等的区域：一个是从空间（From Space）和到空间（To Space）。新创建的对象首先分配在From Space，当垃圾回收发生时，活跃对象会被复制到To Space，并且内存空间的角色会交换，即原来的From Space变为To Space，原来的To Space变为From Space。这个过程会牺牲一定的空间来换取时间效率。
对象晋升：如果对象在多次Scavenge算法后仍然存活，它们会被晋升到老生代。
老生代（Old Generation）
Mark-Sweep（标记-清除）：老生代使用Mark-Sweep算法进行垃圾回收。这个算法分为两个阶段：标记阶段和清除阶段。在标记阶段，垃圾回收器从根对象开始遍历所有可达对象，并标记它们为活跃的。在清除阶段，所有未标记的对象被认定为垃圾，并释放它们占用的内存。
Mark-Compact（标记-整理）：由于Mark-Sweep可能导致内存碎片，V8还使用Mark-Compact算法来整理内存。在标记阶段后，所有活跃对象会被移动到内存的一端，然后清除边界外的内存，这样可以减少内存碎片。
2. 增量标记（Incremental Marking）
为了减少垃圾回收对主线程的影响，V8引入了增量标记。这个策略将标记过程分解成多个小步骤，垃圾回收器在执行标记的同时，会定期暂停让出主线程给JavaScript代码执行。这样可以减少垃圾回收造成的“全停顿”（Stop-The-World）现象，提高应用程序的响应性。

3. 延迟清理（Lazy Sweeping）
V8引擎还采用了延迟清理策略，这意味着垃圾回收器不会立即清理所有的垃圾对象，而是在对象被访问时才进行清理。这有助于减少不必要的垃圾回收操作，提高性能。

4. 并行处理
V8引擎利用多核CPU的优势，采用并行处理来执行垃圾回收的某些阶段。这样可以进一步提高垃圾回收的效率，减少对单线程JavaScript执行的干扰。

5. 大对象区（Large Object Space）
除了新生代和老生代，V8还为大对象（如大型数组或字符串）专门设立了一个区域，称为大对象区。这个区域的垃圾回收不会移动对象，因为大对象通常需要连续的内存空间，移动它们成本较高。

总结
V8引擎通过上述多种策略和算法的组合，实现了高效且对应用程序影响较小的垃圾回收机制。这些机制确保了JavaScript代码能够高效运行，同时避免了内存泄漏和其他内存问题。开发者通常不需要直接参与垃圾回收的过程，但了解这些机制有助于编写更高效的代码，避免潜在的内存问题。


# Scavenge算法是V8引擎在新生代中使用的垃圾回收策略。它的目的是高效地回收短期生命周期的对象，同时尽量减少垃圾回收对JavaScript执行的干扰。下面是Scavenge算法的详细解释和工作流程。
理解Scavenge算法
Scavenge算法基于这样一个观察：大多数JavaScript对象的生命周期都很短，即它们被创建后不久就变得不可达，不再被使用。因此，新生代（Young Generation）被设计为存储这些短期生命周期的对象。Scavenge算法的主要目标是快速地回收这些不再需要的对象，同时保持内存分配的高效性。

Scavenge算法的工作流程
分区域：新生代被分为两个相等的区域，通常称为From Space（FS，活跃区域）和To Space（TS，空闲区域）。新创建的对象首先被分配到From Space。

垃圾回收触发：当From Space几乎被填满时，Scavenge算法的垃圾回收过程被触发。

标记存活对象：在垃圾回收过程中，首先进行存活对象的标记。垃圾回收器从一组根对象（如全局对象、活动闭包等）开始，递归地遍历所有可达的对象。所有从根对象可达的对象都被标记为活跃的。

复制存活对象：标记完成后，垃圾回收器将所有存活的对象从From Space复制到To Space。这个过程同时完成了内存整理，因为所有存活的对象都被移动到了一个连续的内存区域，从而避免了内存碎片的产生。

角色交换：复制完成后，From Space和To Space的角色发生交换。原来的From Space变为下一次垃圾回收的To Space，而原来的To Space变为下一次垃圾回收的From Space。这样，新的内存分配又可以在空的区域中进行。

清理From Space：在角色交换之后，原来的To Space（现在的From Space）中的所有未被复制的对象都被清理掉，因为它们都是不可达的，即垃圾数据。

Scavenge算法的特点
快速分配：由于Scavenge算法不需要在每次分配时都进行垃圾回收，所以对象的分配非常快速。
低延迟：Scavenge算法的垃圾回收过程通常很快，因为它只处理新生代中的对象，而且对象的生命周期通常很短。
空间效率：通过复制存活对象并交换区域角色，Scavenge算法有效地避免了内存碎片的产生，提高了内存的使用效率。
存活对象晋升：那些在多次垃圾回收后仍然存活的对象会被晋升到老生代，这样可以避免在新生代中反复复制这些对象，提高效率。
总结
Scavenge算法是V8引擎在新生代中使用的一种高效的垃圾回收策略。它通过快速地回收短期生命周期的对象，保持了内存分配的高效性，并减少了垃圾回收对JavaScript执行的干扰。通过复制存活对象和区域角色交换，Scavenge算法还避免了内存碎片的产生，从而提高了内存的使用效率。这种算法特别适合处理那些生命周期短的对象，是V8引擎垃圾回收机制中的一个重要组成部分。